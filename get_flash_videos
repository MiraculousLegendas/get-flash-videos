#!/usr/bin/perl
#
# get_flash_videos -- download all the Flash videos off a web page
#
#   http://code.google.com/p/get-flash-videos/
#
# Copyright 2009, zakflash and MonsieurVideo
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain a
# copy of the License at
#   http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.
#
# Contributions are welcome and encouraged, but please take care to
# maintain the JustWorks(tm) nature of the program.
# 

use strict;
use Getopt::Long;
use URI;
use FlashVideo::URLFinder;
use FlashVideo::Downloader;
use FlashVideo::RTMPDownloader;

our $VERSION = "1.1";

my $show_version = 0;
our $yes = 0;

GetOptions(
  "version|v" => \$show_version,
  "yes|y" => \$yes
);

if($show_version) {
  die "get_flash_videos version $VERSION (http://code.google.com/p/get-flash-videos/)\n";
}

binmode STDERR, ":utf8";

my ($url, $filename) = @ARGV;
$url or die "usage: $0 url [filename]\n";

$url = "http://$url" if $url !~ m!^\w+:!;

# Might be downloading from a site that uses Brightcove or other similar
# Flash RTMP streaming server. These are handled differently. Need to get
# the page to determine this.
print STDERR "Downloading $url\n";
my $browser = FlashVideo::URLFinder::get_browser();
$browser->get($url);

# (Redirect check is for Youtube which sometimes redirects to login page
# for "mature" videos.)
if (!$browser->success and !$browser->response->is_redirect) {
  print STDERR "Couldn't download '$url': " . $browser->status_line() . "\n";
}

# Figure out what method we need to call to get either the HTTP URL or
# rtmpdump command for the video. 
my $method = 'generic';

foreach my $host_part (split /\./, URI->new($url)->host) {
  my $possible_method = "site_$host_part";  
  $method = $possible_method and 
    last if FlashVideo::URLFinder->can($possible_method);
}

if($method eq 'generic') {
  # Fairly lame heuristic, look for the first URL outside the <object>
  # element (avoids grabbing things like codebase attribute).
  # Also look at embedded scripts for sites which embed their content that way.
 
  URLS: for my $possible_url(
      $browser->content =~ m!(?:<object[^>]+>.*?|<(?:script|embed) [^>]*src=["']?)(http://[^"'> ]+)!gx) {
    foreach my $host_part (split /\./, URI->new($possible_url)->host) {
      my $possible_method = "site_$host_part";
      if(FlashVideo::URLFinder->can($possible_method)) {
        $method = $possible_method;
        $url = $possible_url;

        # XXX: only support one match, for now
        last URLS;
      }
    }
  }
}

print STDERR "Using method '$method' for $url\n";

my ($actual_url, @suggested_fnames) =
  FlashVideo::URLFinder->$method($browser, $url);
my $suggested_filename = $suggested_fnames[-1];
if (!$yes && @suggested_fnames > 1) {
  print "There are different suggested filenames, please choose:\n";
  my $count;
  foreach my $filename (@suggested_fnames) {
    $count++;
    print "$count - $filename\n";
  }

  print "\nWhat filename would you like to use: ";
  chomp(my $chosen_fname = <STDIN>);

  $suggested_filename = $suggested_fnames[$chosen_fname - 1] ||
    $suggested_fnames[-1];
}

my $save_as = $filename || $suggested_filename;

if (ref($actual_url) or $actual_url =~ /rtmp/) {
  # RTMP
  foreach my $rtmpdump_command ( (ref($actual_url) ? @$actual_url : $actual_url ) ) {
    FlashVideo::RTMPDownloader->new()->download($rtmpdump_command);
  }
}
else {
  # HTTP
  unless(FlashVideo::Downloader->new->download($actual_url, $save_as, $browser)) {
    exit 1;
  }
}

